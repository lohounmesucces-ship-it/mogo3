package templates

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type Renderer struct {
	BaseDir string // ex: /apps/sysdig/data-save/www/alerts
}

func NewRenderer(baseDir string) *Renderer {
	return &Renderer{BaseDir: baseDir}
}

// RenderFromFile charge un template JSON depuis:
// BaseDir/<application>/<filename>
// puis remplace les placeholders ##VAR## par vars["VAR"].
//
// Exemple placeholder: ##INSTANCE##, ##CODEAP##, ##VALUE##, ##SEVERITY##, etc.
func (r *Renderer) RenderFromFile(application, filename string, vars map[string]string) ([]byte, error) {
	app := strings.TrimSpace(application)
	if app == "" {
		return nil, fmt.Errorf("application is empty")
	}

	fn := filepath.Base(strings.TrimSpace(filename))
	if fn == "" {
		return nil, fmt.Errorf("filename is empty")
	}

	p := filepath.Join(r.BaseDir, app, fn)

	b, err := os.ReadFile(p)
	if err != nil {
		return nil, fmt.Errorf("read template %s: %w", p, err)
	}

	out := applyPlaceholders(string(b), vars)
	return []byte(out), nil
}

var placeholderRE = regexp.MustCompile(`##([A-Za-z0-9_]+)##`)

func applyPlaceholders(in string, vars map[string]string) string {
	return placeholderRE.ReplaceAllStringFunc(in, func(m string) string {
		// m = ##KEY##
		key := strings.TrimSuffix(strings.TrimPrefix(m, "##"), "##")
		if v, ok := vars[key]; ok {
			return v
		}
		// si pas fourni, on laisse tel quel (ça aide à debug)
		return m
	})
}
